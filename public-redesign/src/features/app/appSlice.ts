import { createSlice } from '@reduxjs/toolkit';

// export interface OLMapView {
// 	center: Coordinate;
// 	zoom: number;
// 	resolution: number;
// }

// export enum eMapFeaturesLoadingStatus {
// 	LOADING,
// 	SUCCEEDED,
// 	FAILED,
// }

// export enum SearchField {
// 	SymbolName = 'symbol_name',
// 	SchemaTextFields = 'text_fields',
// }

// export enum SearchFieldLabel {
// 	symbol_name = 'Symbol name',
// 	text_fields = 'Text fields',
// }

// export interface SearchParameters {
// 	search_term: string;
// 	search_fields: SearchField[];
// }

export interface AppState {
	// electionId: number | undefined;
	// mapView: Partial<OLMapView> | undefined;
	// mapFeatures: {
	// 	status: eMapFeaturesLoadingStatus | undefined;
	// 	features: GeoJSONFeatureCollection;
	// 	spriteSheet: WebGLLayerSpriteSheet | undefined;
	// };
	// featuresAvailableForEditing: number[];
	// search: {
	// 	parameters: SearchParameters;
	// 	filteredFeatures: number[];
	// };
}

// export const defaultSearchParameters = {
// 	search_term: '',
// 	search_fields: [SearchField.SymbolName, SearchField.SchemaTextFields],
// };

const initialState: AppState = {
	// electionId: undefined,
	// mapView: undefined,
	// mapFeatures: {
	// 	status: undefined,
	// 	features: {
	// 		type: 'FeatureCollection',
	// 		features: [],
	// 	},
	// 	spriteSheet: undefined,
	// },
	// featuresAvailableForEditing: [],
	// search: {
	// 	parameters: defaultSearchParameters,
	// 	filteredFeatures: [],
	// },
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
// export const incrementAsync = createAsyncThunk(
//   "counter/fetchCount",
//   async (amount: number) => {
//     const response = await fetchCount(amount);
//     // The value we return becomes the `fulfilled` action payload
//     return response.data;
//   }
// );

export const appSlice = createSlice({
	name: 'app',
	initialState,
	// The `reducers` field lets us define reducers and generate associated actions
	reducers: {
		// increment: (state) => {
		//   // Redux Toolkit allows us to write "mutating" logic in reducers. It
		//   // doesn't actually mutate the state because it uses the Immer library,
		//   // which detects changes to a "draft state" and produces a brand new
		//   // immutable state based off those changes
		//   state.value += 1;
		// },
		// decrement: (state) => {
		//   state.value -= 1;
		// },
		// Use the PayloadAction type to declare the contents of `action.payload`
		// setActiveElectionId: (state, action: PayloadAction<number | undefined>) => {
		// 	state.electionId = action.payload;
		// },
		// setMapView: (state, action: PayloadAction<Partial<OLMapView>>) => {
		// 	state.mapView = action.payload;
		// },
		// setFeaturesAvailableForEditing: (state, action: PayloadAction<number[]>) => {
		// 	state.featuresAvailableForEditing = action.payload;
		// },
		// setSearchParameters: (state, action: PayloadAction<SearchParameters>) => {
		// 	state.search.parameters = action.payload;
		// },
		// setFilteredFeatures: (state, action: PayloadAction<number[]>) => {
		// 	state.search.filteredFeatures = action.payload;
		// },
	},
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	// extraReducers: (builder) => {
	// 	builder
	// 		.addCase(prepareFeaturesForMap.pending, (state) => {
	// 			state.mapFeatures.status = eMapFeaturesLoadingStatus.LOADING;
	// 		})
	// 		.addCase(prepareFeaturesForMap.fulfilled, (state, action) => {
	// 			state.mapFeatures.status = eMapFeaturesLoadingStatus.SUCCEEDED;
	// 			if (action.payload !== undefined) {
	// 				state.mapFeatures.features = action.payload.geoJSON;
	// 				state.mapFeatures.spriteSheet = action.payload.spriteSheet;
	// 			}
	// 		})
	// 		.addCase(prepareFeaturesForMap.rejected, (state) => {
	// 			state.mapFeatures.status = eMapFeaturesLoadingStatus.FAILED;
	// 		})
	// 		.addMatcher(authApi.endpoints.checkLoginStatus.matchFulfilled, (state, action) => {
	// 			if (action.payload.user?.settings.last_map_id !== undefined) {
	// 				state.mapId = action.payload.user?.settings.last_map_id;
	// 			}
	// 		})
	// 		.addMatcher(authApi.endpoints.updateUserProfile.matchFulfilled, (state, action) => {
	// 			if (action.payload.last_map_id !== undefined) {
	// 				state.mapId = action.payload.last_map_id;
	// 			}
	// 		});
	// },
});

export const {
	/*setActiveElectionId , setMapView, setFeaturesAvailableForEditing, setSearchParameters, setFilteredFeatures*/
} = appSlice.actions;

// export const selectActiveElectionId = (state: RootState) => state.app.electionId;

// export const selectMapView = (state: RootState) => state.app.mapView;

// export const getMapFeatureLoadingStatus = (state: RootState) => state.app.mapFeatures.status;

// export const getGeoJSONFeatures = (state: RootState) => state.app.mapFeatures.features;

// export const getGeoJSONFeaturesSpriteSheet = (state: RootState) => state.app.mapFeatures.spriteSheet;

// export const getFeaturesAvailableForEditing = (state: RootState) => state.app.featuresAvailableForEditing;

// export const getSearchParameters = (state: RootState) => state.app.search.parameters;

// export const getFilteredFeatureIds = (state: RootState) => state.app.search.filteredFeatures;

// export const getCountOfFilteredFeatureIds = (state: RootState) => state.app.search.filteredFeatures.length;

// export const selectActiveMap = createSelector(selectActiveMapId, selectMapsResult, (mapId, maps) =>
// 	mapId !== undefined ? maps.data?.entities[mapId] : undefined,
// );

export default appSlice.reducer;
