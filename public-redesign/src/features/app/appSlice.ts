import { PayloadAction, createSelector, createSlice } from '@reduxjs/toolkit';
import { values } from 'lodash-es';
import { RootState } from '../../app/store';
import { IMapFilterOptions } from '../icons/noms';
import { IMapPollingPlaceGeoJSONFeatureCollection } from '../map/map_stuff';
import { IPollingPlace } from '../pollingPlaces/pollingPlacesInterfaces';

export interface AppState {
	mapFilterOptions: IMapFilterOptions;
	searchBar: {
		initialMode: ESearchDrawerSubComponent;
		searchText: string;
		lonLat: string;
	};
	pollingPlaces: IMapPollingPlaceGeoJSONFeatureCollection | undefined;
	mapFeatures: IPollingPlace | null | undefined;
}

export enum ESearchDrawerSubComponent {
	SEARCH_FIELD = 1,
	REQUEST_LOCATION = 2,
	FILTER_CONTROL = 3,
}

export const initialState: AppState = {
	mapFilterOptions: {},
	searchBar: {
		initialMode: ESearchDrawerSubComponent.SEARCH_FIELD,
		searchText: '',
		lonLat: '',
	},
	pollingPlaces: undefined,
	mapFeatures: undefined,
};

// Used for storing state in localStorage
// pollingPlaces is excluded from storage and
// mapFeatures isn't implemented yet.
export const isAppState = (o: any): o is AppState => {
	return 'mapFilterOptions' in o && 'searchBar' in o;
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
// export const incrementAsync = createAsyncThunk(
//   "counter/fetchCount",
//   async (amount: number) => {
//     const response = await fetchCount(amount);
//     // The value we return becomes the `fulfilled` action payload
//     return response.data;
//   }
// );

export const appSlice = createSlice({
	name: 'app',
	initialState,
	// The `reducers` field lets us define reducers and generate associated actions
	reducers: {
		// increment: (state) => {
		//   // Redux Toolkit allows us to write "mutating" logic in reducers. It
		//   // doesn't actually mutate the state because it uses the Immer library,
		//   // which detects changes to a "draft state" and produces a brand new
		//   // immutable state based off those changes
		//   state.value += 1;
		// },
		// decrement: (state) => {
		//   state.value -= 1;
		// },
		// Use the PayloadAction type to declare the contents of `action.payload`
		// setActiveElectionId: (state, action: PayloadAction<number | undefined>) => {
		// 	state.electionId = action.payload;
		// },
		setMapFilterOptions: (state, action: PayloadAction<IMapFilterOptions>) => {
			state.mapFilterOptions = action.payload;
		},
		setSearchBarInitialMode: (state, action: PayloadAction<ESearchDrawerSubComponent>) => {
			state.searchBar.initialMode = action.payload;
		},
		setSearchBarSearchText: (state, action: PayloadAction<string>) => {
			state.searchBar.searchText = action.payload;
		},
		setSearchBarSearchLonLat: (state, action: PayloadAction<string>) => {
			state.searchBar.lonLat = action.payload;
		},
		setPollingPlaces: (state, action: PayloadAction<IMapPollingPlaceGeoJSONFeatureCollection | undefined>) => {
			state.pollingPlaces = action.payload;
		},
	},
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	// extraReducers: (builder) => {
	// 	builder
	// 		// .addCase(prepareFeaturesForMap.pending, (state) => {
	// 		// 	state.mapFeatures.status = eMapFeaturesLoadingStatus.LOADING;
	// 		// })
	// 		.addCase(prepareFeaturesForMap.fulfilled, (state, action) => {
	// 			// state.mapFeatures.status = eMapFeaturesLoadingStatus.SUCCEEDED;
	// 			// if (action.payload !== undefined) {
	// 			// 	state.mapFeatures = action.payload;
	// 			// }
	// 			state.mapFeatures = action.payload;
	// 		});
	// 	// .addCase(prepareFeaturesForMap.rejected, (state) => {
	// 	// 	state.mapFeatures.status = eMapFeaturesLoadingStatus.FAILED;
	// 	// })
	// },
});

export const {
	setMapFilterOptions,
	setSearchBarInitialMode,
	setSearchBarSearchText,
	setSearchBarSearchLonLat,
	setPollingPlaces,
} = appSlice.actions;

// export const prepareFeaturesForMap = createAsyncThunk(
// 	'app/prepareFeaturesForMap',
// 	async (arg: { electionId: number; name: string; premises: string; state: string } /*, { getState }*/) => {
// 		// const state = getState() as RootState;

// 		// console.log('arg', arg);

// 		try {
// 			const response = await fetch(
// 				`${getAPIBaseURL()}/0.1/polling_places/lookup/?election_id=${arg.electionId}&name=${arg.name}&premises=${
// 					arg.premises
// 				}&state=${arg.state}`,
// 			);

// 			if (response.ok === true) {
// 				// setPollingPlace((await response.json()) as IPollingPlace);
// 				return (await response.json()) as IPollingPlace;
// 			} else {
// 				// setPollingPlace(null);
// 				return null;
// 			}
// 		} catch (error) {
// 			// setPollingPlace(null);
// 			return null;
// 		}
// 	},
// );

export const selectMapFeatures = (state: RootState) => state.app.mapFeatures;

export const selectMapFilterOptions = (state: RootState) => state.app.mapFilterOptions;

export const selectIsMapFiltered = createSelector(
	selectMapFilterOptions,
	(mapFilterOptions) => values(mapFilterOptions).find((option) => option === true) || false,
);

export const selectNumberOfMapFilterOptionsApplied = createSelector(
	selectMapFilterOptions,
	(mapFilterOptions) => values(mapFilterOptions).filter((option) => option === true).length,
);

export const selectSearchBarInitialMode = (state: RootState) => state.app.searchBar.initialMode;

export const selectSearchBarSearchText = (state: RootState) => state.app.searchBar.searchText;

export const selectSearcBarSearchLonLat = (state: RootState) => state.app.searchBar.lonLat;

export const selectPollingPlaces = (state: RootState) => state.app.pollingPlaces;
export default appSlice.reducer;
